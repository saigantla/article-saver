<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVR // Article Archive</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;1,300;1,400&display=swap" rel="stylesheet">

    <!-- PWA Manifest -->
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiQXJ0aWNsZSBBcmNoaXZlIiwic2hvcnRfbmFtZSI6IlNWUiIsInN0YXJ0X3VybCI6Ii8iLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsImJhY2tncm91bmRfY29sb3IiOiIjMGYwZjEyIiwidGhlbWVfY29sb3IiOiIjMDBmM2ZmIn0=">
    <meta name="theme-color" content="#0f0f12">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        obsidian: '#0f0f12',
                        cardbg: '#16161a',
                        cyan: '#00f3ff',
                        dim: '#888890',
                        border: '#2a2a30',
                        reader: '#e0e0e0',
                        sidebar: '#121215'
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                        serif: ['Merriweather', 'serif']
                    },
                    boxShadow: {
                        'neon': '0 0 5px rgba(0, 243, 255, 0.2), 0 0 10px rgba(0, 243, 255, 0.1)',
                    }
                }
            }
        }
    </script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0f0f12; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #00f3ff; }

        /* Reading Progress Bar */
        #progress-bar { transition: width 0.1s ease; }

        /* Smooth Transitions */
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* Typography for Reader */
        .prose-custom p { margin-bottom: 1.8em; line-height: 1.9; color: #d4d4d8; font-size: 1.125rem; }
        .prose-custom h3 { color: #fff; font-weight: 700; margin-top: 2.5em; margin-bottom: 1em; font-size: 1.5em; letter-spacing: -0.02em; font-family: 'Inter', sans-serif; }
        .prose-custom blockquote { border-left: 3px solid #00f3ff; padding-left: 1.5rem; margin: 2rem 0; font-style: italic; color: #a1a1aa; font-size: 1.2rem; background: rgba(255,255,255,0.02); padding: 1.5rem; border-radius: 0 4px 4px 0; }
        .prose-custom ul { list-style-type: disc; padding-left: 1.5rem; margin-bottom: 1.5rem; color: #d4d4d8; }
        .prose-custom li { margin-bottom: 0.5rem; }

        /* Loading Spinner */
        .loader { border: 2px solid #333; border-top: 2px solid #00f3ff; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Tag Styling */
        .tag-pill { display: inline-flex; align-items: center; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.65rem; font-family: 'JetBrains Mono', monospace; background: rgba(0, 243, 255, 0.05); border: 1px solid rgba(0, 243, 255, 0.2); color: #00f3ff; margin-right: 0.5rem; transition: all 0.2s ease; }

        /* Drag & Drop Visuals */
        .article-card[draggable="true"] { cursor: grab; }
        .article-card.dragging { opacity: 0.4; border-color: #00f3ff; box-shadow: 0 0 15px rgba(0, 243, 255, 0.2); transform: scale(0.98); }
        .drop-target { border-color: #00f3ff !important; background-color: rgba(0, 243, 255, 0.1) !important; box-shadow: inset 0 0 10px rgba(0, 243, 255, 0.2); }

        /* Sidebar Item Styling */
        .sidebar-item { transition: all 0.2s; border-left: 2px solid transparent; }
        .sidebar-item:hover, .sidebar-item.active { background: rgba(255,255,255,0.03); color: white; }
        .sidebar-item.active { border-left-color: #00f3ff; color: #00f3ff; }
        .sidebar-item.drop-target { background: rgba(0, 243, 255, 0.15); color: #00f3ff; border-left-color: #00f3ff; }

        /* Checkbox for Selection Mode */
        .custom-checkbox {
            appearance: none;
            background-color: #1a1a1e;
            border: 1px solid #333;
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 0.25rem;
            display: grid;
            place-content: center;
            cursor: pointer;
        }
        .custom-checkbox::before {
            content: "";
            width: 0.75rem;
            height: 0.75rem;
            transform: scale(0);
            transition: 120ms transform ease-in-out;
            box-shadow: inset 1em 1em #00f3ff;
            transform-origin: center;
            clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
        }
        .custom-checkbox.checked::before {
            transform: scale(1);
        }
        .custom-checkbox.checked {
            border-color: #00f3ff;
        }

        /* Karaoke-Style Audio Sync Highlighting */
        .audio-mode .prose-custom p,
        .audio-mode .prose-custom h1,
        .audio-mode .prose-custom h2,
        .audio-mode .prose-custom h3,
        .audio-mode .prose-custom h4,
        .audio-mode .prose-custom h5,
        .audio-mode .prose-custom h6,
        .audio-mode .prose-custom blockquote,
        .audio-mode .prose-custom ul,
        .audio-mode .prose-custom ol {
            transition: opacity 0.5s ease, color 0.3s ease, border-color 0.3s ease;
            opacity: 0.4; /* Dim inactive blocks */
            cursor: pointer; /* Indicate clickable */
        }
        .audio-mode .prose-custom p:hover,
        .audio-mode .prose-custom h1:hover,
        .audio-mode .prose-custom h2:hover,
        .audio-mode .prose-custom h3:hover,
        .audio-mode .prose-custom h4:hover,
        .audio-mode .prose-custom h5:hover,
        .audio-mode .prose-custom h6:hover,
        .audio-mode .prose-custom blockquote:hover,
        .audio-mode .prose-custom ul:hover,
        .audio-mode .prose-custom ol:hover {
            opacity: 0.7; /* Slight hover effect */
        }
        .audio-mode .prose-custom .active-reading-block {
            opacity: 1 !important;
            color: #fff;
            /* Highlight effect with cyan border */
            border-left: 2px solid #00f3ff;
            padding-left: 1rem;
            margin-left: -1rem; /* Compensate padding to keep text aligned */
        }
    </style>
</head>
<body class="bg-obsidian text-gray-300 min-h-screen font-sans antialiased selection:bg-cyan selection:text-black overflow-x-hidden flex flex-col">

    <!-- GLOBAL HEADER -->
    <header class="fixed top-0 w-full bg-obsidian/90 backdrop-blur-md border-b border-border z-40 h-16 flex items-center justify-between px-6 lg:px-8">
        <div class="flex items-center space-x-3 group cursor-pointer" id="header-home-btn">
            <div class="w-2 h-6 bg-cyan group-hover:shadow-neon transition-shadow"></div>
            <h1 class="font-mono font-bold text-lg tracking-widest text-white">SVR<span class="text-dim text-sm font-normal ml-2 hidden sm:inline">// ARCHIVE_NODE</span></h1>
        </div>

        <div class="flex items-center space-x-6">
            <button id="refresh-btn" class="text-dim hover:text-cyan transition-colors" title="Refresh Data">
                <i id="refresh-icon" class="fa-solid fa-arrows-rotate"></i>
            </button>
            <div class="flex items-center space-x-2">
                <div id="status-indicator" class="w-2 h-2 rounded-full" title="Checking..."></div>
                <span id="status-text" class="font-mono text-xs text-dim hidden sm:inline"></span>
            </div>
            <button id="bookmarklet-btn" class="flex items-center space-x-2 border border-border px-4 py-1.5 rounded hover:border-cyan hover:text-cyan transition-colors text-sm font-mono group">
                <i class="fa-solid fa-bookmark text-xs"></i>
                <span>BOOKMARKLET</span>
            </button>
        </div>
    </header>

    <!-- MAIN LAYOUT -->
    <div class="pt-16 min-h-screen flex max-w-[1600px] mx-auto w-full">

        <!-- SIDEBAR (Navigation & Groups) -->
        <aside id="sidebar-panel" class="w-64 fixed lg:static top-16 bottom-0 left-0 bg-sidebar border-r border-border p-4 overflow-y-auto hidden lg:block z-30 transform transition-transform duration-300 -translate-x-full lg:translate-x-0">

            <div class="mb-8">
                <h3 class="font-mono text-[10px] text-dim mb-2 tracking-wider">LIBRARY</h3>
                <nav class="space-y-1">
                    <button data-filter-status="all" class="sidebar-item w-full text-left px-3 py-2 text-sm font-mono text-dim rounded flex justify-between items-center group active" data-val="all">
                        <span>ALL DATA</span>
                        <span id="count-all" class="text-[10px] bg-obsidian px-1.5 py-0.5 rounded text-dim group-hover:text-white">0</span>
                    </button>
                    <button data-filter-status="unread" class="sidebar-item w-full text-left px-3 py-2 text-sm font-mono text-dim rounded flex justify-between items-center group" data-val="unread">
                        <span>UNREAD</span>
                        <span id="count-unread" class="text-[10px] bg-obsidian px-1.5 py-0.5 rounded text-dim group-hover:text-white">0</span>
                    </button>
                    <button data-filter-status="read" class="sidebar-item w-full text-left px-3 py-2 text-sm font-mono text-dim rounded flex justify-between items-center group" data-val="read">
                        <span>READ</span>
                        <span id="count-read" class="text-[10px] bg-obsidian px-1.5 py-0.5 rounded text-dim group-hover:text-white">0</span>
                    </button>
                </nav>
            </div>

            <div>
                <div class="flex justify-between items-center mb-2 px-1">
                    <h3 class="font-mono text-[10px] text-dim tracking-wider">RESEARCH GROUPS</h3>
                    <button id="create-group-btn" class="text-xs text-dim hover:text-cyan" title="New Group">
                        <i class="fa-solid fa-plus"></i>
                    </button>
                </div>

                <div id="group-list" class="space-y-1">
                    <div class="text-center py-4 text-dim text-xs italic">Loading...</div>
                </div>
            </div>
        </aside>

        <!-- CONTENT AREA -->
        <main class="flex-1 px-4 lg:px-8 py-8 w-full">

            <!-- VIEW: LIBRARY -->
            <section id="view-library" class="fade-in block h-full">

                <!-- Tools Bar -->
                <div class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4">

                    <div class="flex items-center w-full md:w-auto space-x-4">
                        <!-- Mobile Menu Toggle -->
                        <button id="mobile-menu-btn" class="lg:hidden text-dim hover:text-white">
                            <i class="fa-solid fa-bars"></i>
                        </button>

                        <!-- Selection Mode Toggle -->
                        <button id="select-mode-btn" class="text-xs font-mono border border-border px-3 py-1.5 rounded text-dim hover:text-white hover:border-white transition-colors flex items-center space-x-2">
                            <i class="fa-regular fa-square-check"></i>
                            <span>SELECT</span>
                        </button>

                        <div id="selection-actions" class="hidden flex items-center space-x-2 animate-pulse">
                            <span class="text-xs font-mono text-cyan"><span id="selected-count">0</span> SELECTED</span>
                            <span class="text-[10px] text-dim hidden sm:inline">(DRAG TO GROUP)</span>
                        </div>
                    </div>

                    <!-- Search -->
                    <div class="relative w-full md:w-80">
                        <i class="fa-solid fa-magnifying-glass absolute left-3 top-1/2 -translate-y-1/2 text-dim text-xs"></i>
                        <input type="text" id="search-input"
                            class="w-full bg-cardbg border border-border rounded py-1.5 pl-8 pr-3 text-xs font-mono text-white focus:border-cyan focus:outline-none placeholder-dim"
                            placeholder="SEARCH ARCHIVE...">
                    </div>
                </div>

                <!-- Article Grid -->
                <div id="article-list" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6 pb-20">
                    <div class="col-span-full flex flex-col items-center justify-center py-20 opacity-50">
                        <div class="loader mb-4"></div>
                        <p class="font-mono text-xs">INITIALIZING CONNECTION...</p>
                    </div>
                </div>
            </section>

            <!-- VIEW: READER -->
            <section id="view-reader" class="hidden fade-in max-w-3xl mx-auto">
                <div class="fixed top-[64px] left-0 h-[2px] bg-cyan shadow-neon z-50 w-0" id="progress-bar"></div>

                <!-- Reader Nav & Controls -->
                <div class="flex justify-between items-center mb-8">
                    <button id="reader-back-btn" class="group flex items-center space-x-2 text-dim hover:text-cyan font-mono text-xs transition-colors">
                        <i class="fa-solid fa-arrow-left group-hover:-translate-x-1 transition-transform"></i>
                        <span>RETURN TO GRID</span>
                    </button>

                    <!-- Parser Controls -->
                    <div class="flex items-center space-x-4">
                        <button id="redrive-btn" title="Redrive Parsing" class="flex items-center space-x-2 font-mono text-xs text-dim hover:text-cyan border border-border hover:border-cyan rounded px-3 py-1 transition-all">
                            <i id="redrive-icon" class="fa-solid fa-rotate-right text-xs"></i>
                            <span class="hidden sm:inline">REDRIVE</span>
                        </button>

                        <button id="btn-generate-audio" class="flex items-center space-x-2 font-mono text-xs text-dim hover:text-cyan border border-border hover:border-cyan rounded px-3 py-1 transition-all">
                            <i class="fa-solid fa-headphones"></i>
                            <span>LISTEN</span>
                        </button>

                        <div class="relative group">
                            <button class="flex items-center space-x-2 font-mono text-xs text-dim hover:text-white border border-border rounded px-3 py-1">
                                <span id="current-parser-label">MODE: READABILITY</span>
                                <i class="fa-solid fa-chevron-down text-[10px]"></i>
                            </button>
                            <div id="parser-dropdown" class="absolute right-0 mt-1 w-48 bg-cardbg border border-border rounded shadow-xl hidden group-hover:block z-50">
                                <button data-parser="readability" class="block w-full text-left px-4 py-2 text-xs font-mono text-dim hover:text-cyan hover:bg-obsidian">READABILITY</button>
                                <button data-parser="defuddle" class="block w-full text-left px-4 py-2 text-xs font-mono text-dim hover:text-cyan hover:bg-obsidian">DEFUDDLE</button>
                                <button data-parser="postlight" class="block w-full text-left px-4 py-2 text-xs font-mono text-dim hover:text-cyan hover:bg-obsidian">POSTLIGHT</button>
                                <button data-parser="llm" class="block w-full text-left px-4 py-2 text-xs font-mono text-dim hover:text-cyan hover:bg-obsidian">LLM</button>
                                <button data-parser="original" class="block w-full text-left px-4 py-2 text-xs font-mono text-dim hover:text-cyan hover:bg-obsidian">RAW HTML</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Article Header -->
                <header class="mb-12 border-b border-border pb-8">
                    <div class="flex flex-wrap items-center gap-3 mb-4 font-mono text-xs text-dim tracking-wider uppercase">
                        <span id="reader-source" class="text-cyan">SOURCE</span>
                        <span>//</span>
                        <span id="reader-author">AUTHOR</span>
                        <span class="mx-2">|</span>
                        <span id="reader-date">DATE</span>
                    </div>

                    <h1 id="reader-title" class="text-3xl md:text-5xl font-bold text-white leading-tight mb-6 font-sans">
                        Article Title
                    </h1>

                    <div class="flex items-center space-x-3 font-mono text-xs text-dim">
                        <span class="bg-cardbg px-2 py-1 rounded border border-border" id="reader-time">5m READ</span>
                        <div id="reader-tags" class="flex items-center">
                            <!-- Tags injected here -->
                        </div>
                    </div>
                </header>

                <!-- Article Content -->
                <div class="relative min-h-[200px]">
                    <article id="reader-content" class="prose-custom text-lg font-serif">
                        <!-- Content injected here -->
                    </article>
                </div>

                <!-- Reader Footer -->
                <div class="mt-16 pt-8 border-t border-border flex justify-between items-center">
                    <button id="scroll-top-btn" class="text-dim hover:text-white font-mono text-xs">
                        [ SCROLL TO TOP ]
                    </button>
                    <div class="flex space-x-4">
                        <button class="text-dim hover:text-cyan font-mono text-xs" id="reader-mark-read">MARK READ</button>
                        <button id="reader-delete-btn" class="text-dim hover:text-red-500 font-mono text-xs">DELETE</button>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- Fixed Bottom Audio Player Bar -->
    <div id="audio-player-bar" class="fixed bottom-0 left-0 w-full bg-obsidian/90 backdrop-blur border-t border-border z-50 hidden transform transition-transform duration-300 translate-y-full flex flex-col">
        <!-- Clickable Progress Bar -->
        <div id="audio-progress-bar" class="w-full h-2 bg-gray-800 cursor-pointer relative group">
            <div id="audio-progress" class="h-full bg-cyan w-0 relative transition-all duration-75 ease-linear">
                <div class="absolute right-0 top-1/2 -translate-y-1/2 w-3 h-3 bg-white rounded-full opacity-0 group-hover:opacity-100"></div>
            </div>
        </div>

        <div class="max-w-3xl mx-auto w-full flex items-center justify-between p-4">
            <div class="flex items-center space-x-4">
                <button id="audio-play-btn" class="w-10 h-10 rounded-full bg-cyan text-black flex items-center justify-center hover:bg-cyan/80 transition-all">
                    <i id="audio-play-icon" class="fa-solid fa-play"></i>
                </button>
                <div class="text-xs font-mono flex flex-col">
                    <span id="audio-status-text" class="text-white">PLAYING AUDIO</span>
                    <span class="text-dim text-[10px]">TAP TEXT TO SCRUB</span>
                </div>
            </div>

            <div class="flex items-center space-x-4">
                <button id="audio-speed-btn" class="font-mono text-xs text-white hover:text-cyan transition-all px-2 py-1">
                    <span id="audio-speed-display">1.0x</span>
                </button>
            </div>
        </div>

        <!-- Hidden audio element -->
        <audio id="main-audio" class="hidden"></audio>
    </div>

    <!-- MODAL: BOOKMARKLET -->
    <div id="modal-bookmarklet" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4">
        <div class="bg-cardbg border border-border w-full max-w-2xl p-6 rounded shadow-2xl relative">
            <button id="close-bookmarklet-btn" class="absolute top-4 right-4 text-dim hover:text-white">
                <i class="fa-solid fa-xmark"></i>
            </button>
            <h2 class="font-mono text-lg text-white mb-6 flex items-center">
                <i class="fa-solid fa-bookmark mr-3 text-cyan"></i> ARTICLE SAVER BOOKMARKLET
            </h2>
            <div class="space-y-4 text-sm text-gray-300">
                <p>Drag this button to your bookmarks bar:</p>
                <div class="flex justify-center my-6">
                    <a href="" id="bookmarklet-link" class="inline-block bg-cyan/10 text-cyan px-6 py-3 rounded border border-cyan hover:bg-cyan hover:text-black transition-all font-mono cursor-move">
                        ðŸ’¾ Save Article
                    </a>
                </div>
                <p class="text-xs text-dim">Use this to save articles from other tabs.</p>
            </div>
        </div>
    </div>

    <!-- IndexedDB Wrapper -->
    <script src="/db.js"></script>

    <!-- JAVASCRIPT LOGIC -->
    <script>
        'use strict';

        // =============================================================================
        // Constants
        // =============================================================================

        const CONFIG = {
            API_BASE: window.location.origin,
            TIMEOUTS: {
                REFRESH_ANIMATION: 800,
                REDRIVE_ANIMATION: 1000,
                API_TIMEOUT: 5000,
                HEALTH_CHECK_TIMEOUT: 3000
            },
            LIMITS: {
                MAX_GROUP_NAME_LENGTH: 100,
                MAX_TOPICS_PER_ARTICLE: 50
            },
            MOBILE_BREAKPOINT: 1024
        };

        // =============================================================================
        // State Management
        // =============================================================================

        const state = {
            articles: [],
            searchResults: [],  // Results from server-side search
            currentArticleId: null,
            currentParserMode: 'readability',
            parserResults: null,
            filters: {
                status: 'all',
                topic: 'all',
                search: ''
            },
            reprocessTriggered: new Set(),
            customGroups: [],
            draggingIds: [],
            selectionMode: false,
            selectedIds: new Set(),
            searchMode: 'client',  // 'client' or 'server'
            // Audio state
            audioUrl: null,
            isGeneratingAudio: false,
            readingMap: []  // Maps paragraphs to audio timestamps for karaoke highlighting
        };

        // =============================================================================
        // DOM Elements Cache
        // =============================================================================

        const els = {
            // Sidebar
            sidebar: document.getElementById('sidebar-panel'),
            groupList: document.getElementById('group-list'),
            countAll: document.getElementById('count-all'),
            countUnread: document.getElementById('count-unread'),
            countRead: document.getElementById('count-read'),

            // Views
            libraryView: document.getElementById('view-library'),
            readerView: document.getElementById('view-reader'),
            articleList: document.getElementById('article-list'),

            // Header
            statusIndicator: document.getElementById('status-indicator'),
            statusText: document.getElementById('status-text'),
            refreshIcon: document.getElementById('refresh-icon'),

            // Selection
            selectBtn: document.getElementById('select-mode-btn'),
            selectionActions: document.getElementById('selection-actions'),
            selectedCount: document.getElementById('selected-count'),

            // Search
            searchInput: document.getElementById('search-input'),

            // Reader
            progressBar: document.getElementById('progress-bar'),
            redriveIcon: document.getElementById('redrive-icon'),
            currentParserLabel: document.getElementById('current-parser-label'),
            rTitle: document.getElementById('reader-title'),
            rSource: document.getElementById('reader-source'),
            rAuthor: document.getElementById('reader-author'),
            rDate: document.getElementById('reader-date'),
            rTime: document.getElementById('reader-time'),
            rContent: document.getElementById('reader-content'),
            rTags: document.getElementById('reader-tags'),
            rMarkRead: document.getElementById('reader-mark-read'),

            // Audio Player
            audioBar: document.getElementById('audio-player-bar'),
            audio: document.getElementById('main-audio'),
            audioProgress: document.getElementById('audio-progress'),
            audioProgressBar: document.getElementById('audio-progress-bar'),
            audioPlayBtn: document.getElementById('audio-play-btn'),
            audioPlayIcon: document.getElementById('audio-play-icon'),
            audioStatusText: document.getElementById('audio-status-text'),
            audioSpeedBtn: document.getElementById('audio-speed-btn'),
            audioSpeedDisplay: document.getElementById('audio-speed-display'),
            btnGenerateAudio: document.getElementById('btn-generate-audio'),

            // Modal
            bookmarkletModal: document.getElementById('modal-bookmarklet'),
            bookmarkletLink: document.getElementById('bookmarklet-link')
        };

        // =============================================================================
        // Utility Functions
        // =============================================================================

        const utils = {
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            sanitizeHtml(html) {
                // Basic sanitization - remove script tags and event handlers
                // For production, consider using DOMPurify library
                if (!html) return '';
                return html
                    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
                    .replace(/on\w+="[^"]*"/g, '')
                    .replace(/on\w+='[^']*'/g, '');
            },

            formatDate(timestamp) {
                if (!timestamp) return 'UNKNOWN';
                try {
                    const date = new Date(timestamp);
                    return date.toISOString().split('T')[0];
                } catch (e) {
                    console.error('Date formatting error:', e);
                    return 'INVALID DATE';
                }
            },

            safeHostname(urlStr) {
                if (!urlStr) return 'UNKNOWN';
                try {
                    return new URL(urlStr).hostname.replace('www.', '');
                } catch (e) {
                    console.warn('Invalid URL:', urlStr);
                    return 'SOURCE';
                }
            },

            validateGroupName(name) {
                if (!name || typeof name !== 'string') {
                    return { valid: false, error: 'Group name is required' };
                }
                const trimmed = name.trim();
                if (trimmed.length === 0) {
                    return { valid: false, error: 'Group name cannot be empty' };
                }
                if (trimmed.length > CONFIG.LIMITS.MAX_GROUP_NAME_LENGTH) {
                    return { valid: false, error: `Group name too long (max ${CONFIG.LIMITS.MAX_GROUP_NAME_LENGTH} chars)` };
                }
                return { valid: true, name: trimmed.toLowerCase() };
            },

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
        };

        // =============================================================================
        // API Functions
        // =============================================================================

        const api = {
            async checkConnection() {
                try {
                    const controller = new AbortController();
                    const timeout = setTimeout(() => controller.abort(), CONFIG.TIMEOUTS.HEALTH_CHECK_TIMEOUT);

                    const response = await fetch(`${CONFIG.API_BASE}/health`, {
                        signal: controller.signal
                    });

                    clearTimeout(timeout);
                    return response.ok;
                } catch (error) {
                    console.warn('Connection check failed:', error);
                    return false;
                }
            },

            async loadArticles() {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), CONFIG.TIMEOUTS.API_TIMEOUT);

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/articles`, {
                        signal: controller.signal
                    });

                    clearTimeout(timeout);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    return await response.json();
                } catch (error) {
                    clearTimeout(timeout);
                    throw error;
                }
            },

            async getArticle(id) {
                const response = await fetch(`${CONFIG.API_BASE}/articles/${id}`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch article: ${response.statusText}`);
                }
                return await response.json();
            },

            async updateArticle(id, data) {
                const response = await fetch(`${CONFIG.API_BASE}/articles/${id}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to update article');
                }

                return await response.json();
            },

            async deleteArticle(id) {
                const response = await fetch(`${CONFIG.API_BASE}/articles/${id}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    throw new Error('Failed to delete article');
                }

                return await response.json();
            },

            async reprocessParser(id, parser) {
                const response = await fetch(`${CONFIG.API_BASE}/articles/${id}/reprocess`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ parser })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to reprocess');
                }

                return await response.json();
            },

            async getArticleHtml(id) {
                const response = await fetch(`${CONFIG.API_BASE}/articles/${id}/html`);
                if (!response.ok) {
                    throw new Error('Failed to fetch HTML');
                }
                return await response.text();
            },

            async searchArticles(query) {
                if (!query || !query.trim()) {
                    throw new Error('Query is required');
                }

                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), CONFIG.TIMEOUTS.API_TIMEOUT);

                try {
                    const response = await fetch(
                        `${CONFIG.API_BASE}/articles/search?q=${encodeURIComponent(query)}`,
                        { signal: controller.signal }
                    );

                    clearTimeout(timeout);

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Search failed');
                    }

                    return await response.json();
                } catch (error) {
                    clearTimeout(timeout);
                    throw error;
                }
            }
        };

        // =============================================================================
        // UI Functions
        // =============================================================================

        const ui = {
            updateConnectionStatus(isOnline) {
                if (isOnline) {
                    els.statusIndicator.className = 'w-2 h-2 rounded-full bg-green-500 shadow-[0_0_10px_#22c55e]';
                    els.statusIndicator.title = "Online";
                    if (els.statusText) els.statusText.textContent = "ONLINE";
                } else {
                    els.statusIndicator.className = 'w-2 h-2 rounded-full bg-yellow-500 shadow-[0_0_10px_#fbbf24]';
                    els.statusIndicator.title = "Offline";
                    if (els.statusText) els.statusText.textContent = "OFFLINE";
                }
            },

            showError(message) {
                console.error(message);
                // Could add toast notification here
                alert(message);
            },

            showLoading(container, message = 'Loading...') {
                if (!container) return;
                container.innerHTML = `
                    <div class="col-span-full flex flex-col items-center justify-center py-20 opacity-50">
                        <div class="loader mb-4"></div>
                        <p class="font-mono text-xs">${utils.escapeHtml(message)}</p>
                    </div>
                `;
            },

            showEmpty(container, message = 'NO ARTICLES FOUND') {
                if (!container) return;
                container.innerHTML = `
                    <div class="col-span-full flex flex-col items-center justify-center py-20 border border-dashed border-border rounded text-dim">
                        <p class="font-mono text-sm mb-4">${utils.escapeHtml(message)}</p>
                    </div>
                `;
            }
        };

        // =============================================================================
        // App Functions
        // =============================================================================

        const app = {
            async init() {
                try {
                    // Initialize IndexedDB
                    if (typeof db !== 'undefined' && db.init) {
                        await db.init();
                    }

                    // Check connection and load data
                    const isOnline = await api.checkConnection();
                    if (isOnline) {
                        await app.loadArticles();
                    } else {
                        await app.loadArticlesFromCache();
                    }

                    // Service Worker
                    if ('serviceWorker' in navigator) {
                        navigator.serviceWorker.register('/sw.js').catch(e =>
                            console.error('Service worker registration failed:', e)
                        );
                    }

                    // Setup event listeners
                    app.setupEventListeners();

                    // Generate bookmarklet
                    app.generateBookmarklet();

                } catch (error) {
                    console.error('Initialization error:', error);
                    ui.showError('Failed to initialize application');
                }
            },

            setupEventListeners() {
                // Header
                document.getElementById('header-home-btn')?.addEventListener('click', () => app.goHome());
                document.getElementById('refresh-btn')?.addEventListener('click', () => app.refreshData());
                document.getElementById('bookmarklet-btn')?.addEventListener('click', () => app.openBookmarkletModal());
                document.getElementById('close-bookmarklet-btn')?.addEventListener('click', () => app.closeBookmarkletModal());

                // Sidebar
                document.getElementById('mobile-menu-btn')?.addEventListener('click', () => {
                    els.sidebar?.classList.toggle('-translate-x-full');
                });
                document.getElementById('create-group-btn')?.addEventListener('click', () => app.createNewGroup());

                document.querySelectorAll('[data-filter-status]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const status = e.currentTarget.dataset.filterStatus;
                        app.setFilter('status', status);
                    });
                });

                // Selection
                document.getElementById('select-mode-btn')?.addEventListener('click', () => app.toggleSelectionMode());

                // Search
                if (els.searchInput) {
                    const debouncedSearch = utils.debounce((value) => {
                        app.handleSearch(value);
                    }, 300);  // Wait 300ms after user stops typing

                    els.searchInput.addEventListener('input', (e) => {
                        debouncedSearch(e.target.value);
                    });
                }

                // Reader
                document.getElementById('reader-back-btn')?.addEventListener('click', () => app.goHome());
                document.getElementById('redrive-btn')?.addEventListener('click', () => app.redriveParsing());
                document.getElementById('scroll-top-btn')?.addEventListener('click', () => {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });
                document.getElementById('reader-delete-btn')?.addEventListener('click', () => app.deleteCurrent());

                // Audio controls
                els.btnGenerateAudio?.addEventListener('click', () => app.generateAudio());
                els.audioPlayBtn?.addEventListener('click', () => app.toggleAudioPlay());
                els.audioSpeedBtn?.addEventListener('click', () => app.changePlaybackRate());
                els.audioProgressBar?.addEventListener('click', (e) => app.seekAudio(e));
                els.audio?.addEventListener('timeupdate', () => app.updateAudioProgress());
                els.audio?.addEventListener('ended', () => app.onAudioEnded());

                // Parser dropdown
                document.querySelectorAll('[data-parser]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const parser = e.currentTarget.dataset.parser;
                        app.setParser(parser);
                    });
                });

                // Scroll progress
                window.addEventListener('scroll', () => {
                    if (els.readerView?.classList.contains('hidden')) return;
                    const scrollTop = window.scrollY;
                    const docHeight = document.body.offsetHeight - window.innerHeight;
                    const scrollPercent = (scrollTop / docHeight) * 100;
                    if (els.progressBar) {
                        els.progressBar.style.width = Math.min(100, Math.max(0, scrollPercent)) + '%';
                    }
                });
            },

            async loadArticlesFromCache() {
                try {
                    if (typeof db !== 'undefined') {
                        state.articles = await db.getAllArticles();
                        app.renderLibrary();
                        app.renderGroupList();
                    }
                } catch (error) {
                    console.error('Failed to load from cache:', error);
                }
            },

            async loadArticles() {
                try {
                    const articles = await api.loadArticles();

                    // Cache articles
                    if (typeof db !== 'undefined') {
                        await db.saveArticles(articles);
                    }

                    state.articles = articles;
                    ui.updateConnectionStatus(true);
                    app.renderLibrary();
                    app.renderGroupList();
                } catch (error) {
                    console.warn("Network failed, using cache fallback", error);
                    ui.updateConnectionStatus(false);
                    await app.loadArticlesFromCache();
                }
            },

            refreshData() {
                if (els.refreshIcon) els.refreshIcon.classList.add('fa-spin');

                app.loadArticles().finally(() => {
                    setTimeout(() => {
                        if (els.refreshIcon) els.refreshIcon.classList.remove('fa-spin');
                    }, CONFIG.TIMEOUTS.REFRESH_ANIMATION);
                });
            },

            // Selection Mode
            toggleSelectionMode() {
                state.selectionMode = !state.selectionMode;
                state.selectedIds.clear();

                if (state.selectionMode) {
                    els.selectBtn?.classList.add('bg-cyan/10', 'border-cyan', 'text-cyan');
                    els.selectionActions?.classList.remove('hidden');
                } else {
                    els.selectBtn?.classList.remove('bg-cyan/10', 'border-cyan', 'text-cyan');
                    els.selectionActions?.classList.add('hidden');
                }

                app.renderLibrary();
                app.updateSelectedCount();
            },

            toggleSelectArticle(id, e) {
                e.stopPropagation();

                if (state.selectedIds.has(id)) {
                    state.selectedIds.delete(id);
                } else {
                    state.selectedIds.add(id);
                }

                app.renderLibrary();
                app.updateSelectedCount();
            },

            updateSelectedCount() {
                if (els.selectedCount) {
                    els.selectedCount.textContent = state.selectedIds.size;
                }
            },

            // Filters
            setFilter(type, val) {
                if (type === 'status') {
                    state.filters.topic = 'all';
                    state.filters.status = val;
                } else if (type === 'topic') {
                    state.filters.status = 'all';
                    state.filters.topic = val;
                }

                document.querySelectorAll('.sidebar-item').forEach(el => {
                    const matchesStatus = el.dataset.val === val;
                    const matchesTopic = type === 'topic' && el.dataset.topic === val;

                    if (matchesStatus || matchesTopic) {
                        el.classList.add('active');
                    } else {
                        el.classList.remove('active');
                    }
                });

                // Close sidebar on mobile
                if (window.innerWidth < CONFIG.MOBILE_BREAKPOINT && els.sidebar) {
                    els.sidebar.classList.add('-translate-x-full');
                }

                app.renderLibrary();
            },

            getFilteredArticles() {
                // If in server search mode, use search results directly
                // (server already filtered by search term)
                if (state.searchMode === 'server' && state.filters.search) {
                    return state.searchResults.filter(a => {
                        // Still apply status and topic filters
                        if (state.filters.status === 'read' && a.status !== 'read') return false;
                        if (state.filters.status === 'unread' && a.status === 'read') return false;

                        if (state.filters.topic !== 'all') {
                            const topics = a.topics || [];
                            if (!topics.includes(state.filters.topic)) return false;
                        }

                        return true;
                    });
                }

                // Client-side filtering on all articles
                return state.articles.filter(a => {
                    // Status filter
                    if (state.filters.status === 'read' && a.status !== 'read') return false;
                    if (state.filters.status === 'unread' && a.status === 'read') return false;

                    // Topic filter
                    if (state.filters.topic !== 'all') {
                        const topics = a.topics || [];
                        if (!topics.includes(state.filters.topic)) return false;
                    }

                    // Search filter (client-side fallback - only searches title/snippet/author)
                    if (state.filters.search && state.filters.search.trim()) {
                        const term = state.filters.search.toLowerCase();
                        const title = (a.title || '').toLowerCase();
                        const snippet = (a.snippet || '').toLowerCase();
                        const author = (a.author || '').toLowerCase();
                        const source = (a.source_domain || '').toLowerCase();

                        if (!title.includes(term) &&
                            !snippet.includes(term) &&
                            !author.includes(term) &&
                            !source.includes(term)) {
                            return false;
                        }
                    }

                    return true;
                });
            },

            // Search
            async handleSearch(query) {
                query = query ? query.trim() : '';
                state.filters.search = query;

                // If no query, show all articles with current filters
                if (!query) {
                    state.searchMode = 'client';
                    app.renderLibrary();
                    return;
                }

                // For search queries, use server-side search to access full article content
                // The server can search through text_content which isn't in the article list
                try {
                    state.searchMode = 'server';
                    ui.showLoading(els.articleList, 'SEARCHING...');

                    const response = await api.searchArticles(query);

                    // Temporarily replace articles with search results
                    state.searchResults = response.results;
                    app.renderLibrary();

                    console.log(`Search for "${query}" found ${response.count} results`);
                } catch (error) {
                    console.error('Search failed:', error);
                    // Fall back to client-side search on cached data
                    state.searchMode = 'client';
                    app.renderLibrary();
                }
            },

            // Groups
            createNewGroup() {
                const name = prompt("Enter new Group Name:");
                if (!name) return;

                const validation = utils.validateGroupName(name);
                if (!validation.valid) {
                    ui.showError(validation.error);
                    return;
                }

                const cleanName = validation.name;
                if (!state.customGroups.includes(cleanName)) {
                    state.customGroups.push(cleanName);
                }

                app.renderGroupList();
            },

            renderGroupList() {
                if (!els.groupList) return;

                const allTopics = new Set(state.customGroups);
                state.articles.forEach(a => {
                    const topics = a.topics || [];
                    topics.forEach(t => allTopics.add(t));
                });

                const sortedTopics = Array.from(allTopics).sort();

                if (sortedTopics.length === 0) {
                    els.groupList.innerHTML = '<div class="text-center py-4 text-dim text-xs italic">No groups yet.</div>';
                    return;
                }

                let html = '';
                sortedTopics.forEach(topic => {
                    const count = state.articles.filter(a => (a.topics || []).includes(topic)).length;
                    const isActive = state.filters.topic === topic;
                    const escapedTopic = utils.escapeHtml(topic);

                    html += `
                        <button
                            data-filter-topic="${escapedTopic}"
                            data-topic="${escapedTopic}"
                            class="sidebar-item w-full text-left px-3 py-2 text-sm font-mono text-dim rounded flex justify-between items-center group ${isActive ? 'active' : ''}"
                        >
                            <span class="truncate pr-2"># ${escapedTopic.toUpperCase()}</span>
                            <span class="text-[10px] bg-obsidian px-1.5 py-0.5 rounded text-dim group-hover:text-white">${count}</span>
                        </button>
                    `;
                });

                els.groupList.innerHTML = html;

                // Add event listeners to new group buttons
                document.querySelectorAll('[data-filter-topic]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const topic = e.currentTarget.dataset.filterTopic;
                        app.setFilter('topic', topic);
                    });

                    // Drag and drop
                    btn.addEventListener('dragover', (e) => app.handleDragOver(e));
                    btn.addEventListener('drop', (e) => {
                        const topic = e.currentTarget.dataset.filterTopic;
                        app.handleDropOnGroup(e, topic);
                    });
                    btn.addEventListener('dragleave', (e) => app.handleDragLeave(e));
                });

                // Update counts
                if (els.countAll) els.countAll.textContent = state.articles.length;
                if (els.countUnread) els.countUnread.textContent = state.articles.filter(a => a.status !== 'read').length;
                if (els.countRead) els.countRead.textContent = state.articles.filter(a => a.status === 'read').length;
            },

            // Drag & Drop
            handleDragStart(e, id) {
                if (state.selectionMode && state.selectedIds.has(id)) {
                    state.draggingIds = Array.from(state.selectedIds);
                    e.dataTransfer.setData('text/plain', `${state.draggingIds.length} items`);
                } else {
                    state.draggingIds = [id];
                    e.dataTransfer.setData('text/plain', '1 item');
                }

                e.dataTransfer.effectAllowed = 'copyMove';

                setTimeout(() => {
                    state.draggingIds.forEach(dId => {
                        const card = document.getElementById(`card-${dId}`);
                        if (card) card.classList.add('dragging');
                    });
                }, 0);
            },

            handleDragEnd(e) {
                state.draggingIds.forEach(id => {
                    const card = document.getElementById(`card-${id}`);
                    if (card) card.classList.remove('dragging');
                });
                state.draggingIds = [];
                document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
            },

            handleDragOver(e) {
                e.preventDefault();
                e.currentTarget.classList.add('drop-target');
            },

            handleDragLeave(e) {
                e.currentTarget.classList.remove('drop-target');
            },

            async handleDropOnGroup(e, topic) {
                e.preventDefault();
                e.currentTarget.classList.remove('drop-target');

                const ids = state.draggingIds;
                if (ids.length === 0) return;

                const promises = ids.map(async (id) => {
                    const article = state.articles.find(a => a.id === id);
                    if (!article) return;

                    let newTopics = article.topics || [];
                    if (!newTopics.includes(topic)) {
                        newTopics = [...newTopics, topic];  // Create new array for immutability
                        article.topics = newTopics; // Optimistic update

                        try {
                            await api.updateArticle(id, { topics: newTopics });
                        } catch (error) {
                            console.error(`Failed to update article ${id}:`, error);
                            // Revert on error
                            article.topics = article.topics.filter(t => t !== topic);
                            throw error;
                        }
                    }
                });

                try {
                    await Promise.all(promises);
                    app.renderLibrary();
                    app.renderGroupList();
                } catch (err) {
                    ui.showError("Failed to update some articles");
                }
            },

            // Rendering
            renderLibrary() {
                if (!els.articleList) return;

                const filtered = app.getFilteredArticles();
                els.articleList.innerHTML = '';

                if (filtered.length === 0) {
                    ui.showEmpty(els.articleList);
                    return;
                }

                filtered.forEach(article => {
                    const isRead = article.status === 'read';
                    const isSelected = state.selectedIds.has(article.id);

                    const card = document.createElement('article');
                    card.id = `card-${article.id}`;
                    card.setAttribute('draggable', 'true');
                    card.className = `article-card group relative bg-cardbg border ${isSelected ? 'border-cyan' : 'border-border'} rounded p-5 transition-all duration-200 hover:shadow-neon cursor-grab flex flex-col h-full ${isRead ? 'opacity-60 hover:opacity-100' : ''}`;

                    // Build tags HTML safely
                    const tags = (article.topics || [])
                        .map(t => `<span class="text-[10px] text-cyan mr-2">#${utils.escapeHtml(t)}</span>`)
                        .join('');

                    // Sanitize snippet
                    const snippet = utils.escapeHtml(article.snippet || "No preview.");
                    const title = utils.escapeHtml(article.title);
                    const hostname = utils.escapeHtml(utils.safeHostname(article.source || article.archive_url));
                    const readTime = utils.escapeHtml(article.readTime || '3m');
                    const date = utils.escapeHtml(utils.formatDate(article.captured_at));

                    card.innerHTML = `
                        <div class="absolute top-4 right-4 z-10 ${state.selectionMode ? 'block' : 'hidden'}">
                            <div class="custom-checkbox ${isSelected ? 'checked' : ''}" data-article-id="${article.id}"></div>
                            ${isSelected ? '<i class="fa-solid fa-check text-[10px] text-cyan absolute inset-0 m-auto pointer-events-none"></i>' : ''}
                        </div>

                        <div class="flex justify-between items-start mb-2 pointer-events-none">
                            <h2 class="text-lg font-semibold text-gray-100 group-hover:text-white transition-colors leading-tight pr-8 line-clamp-2">
                                ${title}
                            </h2>
                        </div>

                        <div class="flex items-center space-x-2 mb-2 font-mono text-[10px] text-dim tracking-wider uppercase pointer-events-none">
                            <span class="text-cyan truncate max-w-[100px]">${hostname}</span>
                            <span class="text-dim">|</span>
                            <span class="font-bold">${readTime}</span>
                        </div>

                        <div class="mb-4 font-mono pointer-events-none">${tags}</div>

                        <div class="relative flex-grow pointer-events-none">
                             <p class="text-sm text-gray-400 leading-relaxed mb-6 line-clamp-3 border-l-2 border-transparent group-hover:border-cyan pl-0 group-hover:pl-3 transition-all duration-300">
                                ${snippet}
                            </p>
                        </div>

                        <div class="flex justify-between items-center pt-4 border-t border-border group-hover:border-gray-800 transition-colors mt-auto">
                            <div class="font-mono text-[10px] text-dim flex items-center pointer-events-none">
                                ${isRead ? '<i class="fa-solid fa-check mr-2 text-green-500"></i>' : ''}
                                ${date}
                            </div>

                            <div class="flex space-x-3 opacity-100 sm:opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                                <button data-action="toggle-read" data-article-id="${article.id}" class="text-xs font-mono text-dim hover:text-white flex items-center transition-colors">
                                    <i class="fa-${isRead ? 'regular' : 'solid'} fa-circle-check"></i>
                                </button>
                                <button data-action="read" data-article-id="${article.id}" class="text-xs font-mono font-bold text-dim hover:text-cyan flex items-center transition-colors">
                                    [ READ ]
                                </button>
                                <button data-action="delete" data-article-id="${article.id}" class="text-xs font-mono text-dim hover:text-red-400 flex items-center transition-colors">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                            </div>
                        </div>
                    `;

                    // Event listeners
                    card.addEventListener('dragstart', (e) => app.handleDragStart(e, article.id));
                    card.addEventListener('dragend', (e) => app.handleDragEnd(e));

                    card.addEventListener('click', (e) => {
                        if (state.selectionMode) {
                            app.toggleSelectArticle(article.id, e);
                        } else {
                            app.openReader(article.id);
                        }
                    });

                    // Add event listeners to buttons
                    const checkbox = card.querySelector('.custom-checkbox');
                    if (checkbox) {
                        checkbox.addEventListener('click', (e) => app.toggleSelectArticle(article.id, e));
                    }

                    const toggleReadBtn = card.querySelector('[data-action="toggle-read"]');
                    if (toggleReadBtn) {
                        toggleReadBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            app.toggleReadStatus(article.id, !isRead);
                        });
                    }

                    const readBtn = card.querySelector('[data-action="read"]');
                    if (readBtn) {
                        readBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            app.openReader(article.id);
                        });
                    }

                    const deleteBtn = card.querySelector('[data-action="delete"]');
                    if (deleteBtn) {
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            app.deleteArticle(article.id);
                        });
                    }

                    els.articleList.appendChild(card);
                });
            },

            // Reader
            async openReader(id) {
                try {
                    const article = await api.getArticle(id);

                    // Cache article
                    if (typeof db !== 'undefined') {
                        try {
                            await db.saveArticle(article);
                        } catch (e) {
                            console.warn("Failed to cache article", e);
                        }
                    }

                    state.currentArticleId = id;
                    state.parserResults = article.parser_results || {};
                    state.reprocessTriggered.clear();

                    // Populate reader (with sanitization)
                    if (els.rTitle) els.rTitle.textContent = article.title;
                    if (els.rSource) els.rSource.textContent = utils.safeHostname(article.source || article.archive_url);
                    if (els.rAuthor) els.rAuthor.textContent = article.author || 'UNKNOWN';
                    if (els.rDate) els.rDate.textContent = utils.formatDate(article.captured_at);
                    if (els.rTime) els.rTime.textContent = (article.readTime || '5m') + ' READ';

                    // Sanitize and set content
                    if (els.rContent) {
                        const sanitized = utils.sanitizeHtml(article.content || "");
                        els.rContent.innerHTML = sanitized || "<p>Content loading error.</p>";
                    }

                    // Tags
                    if (els.rTags) {
                        const tagsHtml = (article.topics || [])
                            .map(t => `<span class="tag-pill ml-2">${utils.escapeHtml(t.toUpperCase())}</span>`)
                            .join('');
                        els.rTags.innerHTML = tagsHtml;
                    }

                    // Mark read button
                    const isRead = article.status === 'read';
                    if (els.rMarkRead) {
                        els.rMarkRead.textContent = isRead ? "MARK UNREAD" : "MARK READ";
                        els.rMarkRead.onclick = () => app.toggleReadStatus(id, !isRead);
                    }

                    // Setup audio player
                    app.setupAudio(article);

                    // Set parser mode
                    app.setParser('readability');

                    // Show reader view
                    els.libraryView?.classList.add('hidden');
                    els.readerView?.classList.remove('hidden');
                    els.sidebar?.classList.add('hidden');
                    window.scrollTo(0, 0);

                } catch (error) {
                    console.error('Error opening article:', error);
                    ui.showError("Error opening article: " + error.message);
                }
            },

            goHome() {
                els.readerView?.classList.add('hidden');
                els.libraryView?.classList.remove('hidden');
                els.sidebar?.classList.remove('hidden');
                state.currentArticleId = null;
                if (els.progressBar) els.progressBar.style.width = '0%';

                // Hide audio bar when leaving reader
                if (els.audioBar) {
                    els.audioBar.classList.add('hidden', 'translate-y-full');
                    els.audioBar.classList.remove('translate-y-0');
                }
                if (els.audio) {
                    els.audio.pause();
                }

                // Clear audio mode and highlighting
                if (els.rContent && els.rContent.parentElement) {
                    els.rContent.parentElement.classList.remove('audio-mode');
                }
                if (state.readingMap) {
                    state.readingMap.forEach(item => item.el.classList.remove('active-reading-block'));
                }
                state.readingMap = [];
            },

            async toggleReadStatus(id, markAsRead) {
                if (!id) return;

                const status = markAsRead ? 'read' : 'unread';

                // Optimistic update
                const article = state.articles.find(a => a.id === id);
                if (article) {
                    const oldStatus = article.status;
                    article.status = status;
                    app.renderLibrary();
                    app.renderGroupList();

                    if (state.currentArticleId === id && els.rMarkRead) {
                        els.rMarkRead.textContent = markAsRead ? "MARK UNREAD" : "MARK READ";
                        els.rMarkRead.onclick = () => app.toggleReadStatus(id, !markAsRead);
                    }

                    try {
                        await api.updateArticle(id, { status });
                    } catch (error) {
                        // Revert on error
                        article.status = oldStatus;
                        app.renderLibrary();
                        app.renderGroupList();
                        ui.showError("Failed to update status");
                    }
                }
            },

            async setParser(mode) {
                state.currentParserMode = mode;

                if (els.currentParserLabel) {
                    els.currentParserLabel.textContent = `MODE: ${mode.toUpperCase()}`;
                }

                const id = state.currentArticleId;
                if (!id || !els.rContent) return;

                if (mode === 'original') {
                    try {
                        const htmlText = await api.getArticleHtml(id);
                        // Use iframe for safety
                        const escapedHtml = htmlText.replace(/"/g, '&quot;');
                        els.rContent.innerHTML = `<iframe srcdoc="${escapedHtml}" style="width:100%; min-height:800px; border:none; background:white;" sandbox="allow-same-origin"></iframe>`;
                    } catch (e) {
                        console.error('Failed to load HTML:', e);
                        els.rContent.innerHTML = "<p class='text-red-400'>Failed to load HTML.</p>";
                    }
                    return;
                }

                // All parsers (including LLM) use parser_results
                const parserResult = state.parserResults ? state.parserResults[mode] : null;

                if (parserResult && parserResult.success) {
                    // LLM stores in 'content', others store in 'htmlContent'
                    const content = parserResult.content || parserResult.htmlContent;
                    if (content) {
                        els.rContent.innerHTML = utils.sanitizeHtml(content);
                    } else {
                        els.rContent.innerHTML = `<div class="text-center py-12 text-dim">Parser content not available.</div>`;
                    }
                } else {
                    els.rContent.innerHTML = `<div class="text-center py-12 text-dim">Parser content not available.</div>`;
                }
            },

            async redriveParsing() {
                const id = state.currentArticleId;
                const mode = state.currentParserMode;

                if (!id) return;

                if (els.redriveIcon) els.redriveIcon.classList.add('fa-spin');

                try {
                    // Use streaming for LLM parser, polling for others
                    if (mode === 'llm') {
                        await this.redriveParsingStreaming(id, mode);
                    } else {
                        await this.redriveParsingPolling(id, mode);
                    }
                } catch (error) {
                    console.error('Redrive failed:', error);
                    if (els.redriveIcon) els.redriveIcon.classList.remove('fa-spin');
                    ui.showError("Failed to reprocess: " + error.message);
                }
            },

            async redriveParsingStreaming(id, mode) {
                // Show initial streaming UI
                if (els.rContent) {
                    els.rContent.innerHTML = `
                        <div id="streaming-header" class="sticky top-0 bg-bg/95 backdrop-blur-sm border-b border-cyan-500/30 p-3 mb-4 rounded-lg flex items-center justify-between">
                            <div class="flex items-center gap-3">
                                <i class="fa-solid fa-circle-notch fa-spin text-cyan-400 text-sm"></i>
                                <span class="text-cyan-400 font-mono text-xs" id="streaming-status">Starting...</span>
                            </div>
                            <div class="text-dim font-mono text-xs" id="streaming-progress">0 chars</div>
                        </div>
                        <div id="streaming-content" class="prose prose-invert max-w-none"></div>
                    `;
                }

                const statusEl = document.getElementById('streaming-status');
                const progressEl = document.getElementById('streaming-progress');
                const contentEl = document.getElementById('streaming-content');
                const headerEl = document.getElementById('streaming-header');
                let accumulatedContent = '';
                let charCount = 0;

                return new Promise((resolve, reject) => {
                    const eventSource = new EventSource(`/articles/${id}/reprocess-stream`);

                    eventSource.addEventListener('status', (e) => {
                        const data = JSON.parse(e.data);
                        console.log('Status:', data);

                        // Update status message
                        if (statusEl) {
                            statusEl.textContent = data.message || 'Processing...';
                        }
                    });

                    eventSource.addEventListener('chunk', (e) => {
                        const data = JSON.parse(e.data);
                        const chunkText = data.text;

                        console.log('Chunk received:', chunkText.length, 'chars');

                        // Accumulate content
                        accumulatedContent += chunkText;
                        charCount += chunkText.length;

                        // Update progress counter
                        if (progressEl) {
                            progressEl.textContent = `${charCount.toLocaleString()} chars`;
                        }

                        // Render the HTML progressively (even if incomplete tags)
                        if (contentEl) {
                            contentEl.innerHTML = accumulatedContent;

                            // Auto-scroll to show new content (smoothly)
                            if (contentEl.lastElementChild) {
                                contentEl.lastElementChild.scrollIntoView({
                                    behavior: 'smooth',
                                    block: 'end'
                                });
                            }
                        }
                    });

                    eventSource.addEventListener('done', async (e) => {
                        const data = JSON.parse(e.data);
                        console.log('Streaming complete:', data);

                        eventSource.close();

                        // Remove streaming header with smooth transition
                        if (headerEl) {
                            headerEl.style.opacity = '0';
                            headerEl.style.transition = 'opacity 0.3s ease-out';
                            setTimeout(() => headerEl.remove(), 300);
                        }

                        // Update parser results with the streamed result
                        if (data.result && data.result.success) {
                            state.parserResults = state.parserResults || {};
                            state.parserResults[mode] = data.result;

                            // Display final content (clean render)
                            if (contentEl) {
                                const finalContent = data.content || data.result.content;
                                contentEl.innerHTML = finalContent;

                                // Add a subtle success indicator
                                const successBadge = document.createElement('div');
                                successBadge.className = 'mt-4 p-2 bg-green-900/20 border border-green-500/30 rounded text-center';
                                successBadge.innerHTML = `
                                    <i class="fa-solid fa-check text-green-400 mr-2"></i>
                                    <span class="text-green-400 font-mono text-xs">Completed - ${charCount.toLocaleString()} chars generated</span>
                                `;
                                contentEl.appendChild(successBadge);

                                // Remove success badge after 3 seconds
                                setTimeout(() => {
                                    successBadge.style.opacity = '0';
                                    successBadge.style.transition = 'opacity 0.5s ease-out';
                                    setTimeout(() => successBadge.remove(), 500);
                                }, 3000);
                            }
                        }

                        // Fetch updated article metadata (async, don't block display)
                        api.getArticle(id).then(article => {
                            // Update cached article with new metadata
                            const cachedArticle = state.articles.find(a => a.id === id);
                            if (cachedArticle) {
                                Object.assign(cachedArticle, {
                                    title: article.title,
                                    author: article.author,
                                    snippet: article.snippet,
                                    text_length: article.text_length,
                                    readTime: article.readTime
                                });
                            }

                            // Update state with latest parser results from DB
                            state.parserResults = article.parser_results || state.parserResults;
                        }).catch(err => {
                            console.warn('Failed to fetch updated article metadata:', err);
                            // Content is already displayed, so this is non-critical
                        });

                        if (els.redriveIcon) els.redriveIcon.classList.remove('fa-spin');
                        resolve();
                    });

                    eventSource.addEventListener('error', (e) => {
                        let errorMsg = 'Unknown error';

                        if (e.data) {
                            try {
                                const data = JSON.parse(e.data);
                                errorMsg = data.message || errorMsg;
                            } catch (err) {
                                // Ignore parse error
                            }
                        }

                        console.error('Streaming error:', errorMsg);
                        eventSource.close();

                        // Show error message
                        if (els.rContent) {
                            els.rContent.innerHTML = `
                                <div class="bg-red-900/20 border border-red-500/30 rounded-lg p-6 text-center">
                                    <i class="fa-solid fa-triangle-exclamation text-red-400 text-2xl mb-3"></i>
                                    <h3 class="text-red-400 font-mono text-sm mb-2">PARSER FAILED</h3>
                                    <p class="text-dim text-xs">${utils.escapeHtml(errorMsg)}</p>
                                </div>
                            `;
                        }

                        if (els.redriveIcon) els.redriveIcon.classList.remove('fa-spin');
                        reject(new Error(errorMsg));
                    });

                    // Handle connection errors
                    eventSource.onerror = async (e) => {
                        // Only handle if not already closed
                        if (eventSource.readyState !== EventSource.CLOSED) {
                            console.error('EventSource connection error', e);
                            eventSource.close();

                            // Try to fetch the error message from the endpoint
                            try {
                                const response = await fetch(`/articles/${id}/reprocess-stream`);
                                if (!response.ok) {
                                    const errorData = await response.json();
                                    const errorMsg = errorData.error || 'Connection error';

                                    if (els.rContent) {
                                        els.rContent.innerHTML = `
                                            <div class="bg-red-900/20 border border-red-500/30 rounded-lg p-6 text-center">
                                                <i class="fa-solid fa-triangle-exclamation text-red-400 text-2xl mb-3"></i>
                                                <h3 class="text-red-400 font-mono text-sm mb-2">STREAMING FAILED</h3>
                                                <p class="text-dim text-xs">${utils.escapeHtml(errorMsg)}</p>
                                            </div>
                                        `;
                                    }

                                    if (els.redriveIcon) els.redriveIcon.classList.remove('fa-spin');
                                    reject(new Error(errorMsg));
                                    return;
                                }
                            } catch (fetchError) {
                                console.error('Could not fetch error details:', fetchError);
                            }

                            if (els.redriveIcon) els.redriveIcon.classList.remove('fa-spin');
                            reject(new Error('Connection lost'));
                        }
                    };
                });
            },

            async redriveParsingPolling(id, mode) {
                // Trigger reprocessing
                await api.reprocessParser(id, mode);

                // Poll for updated results (check every 2 seconds for up to 30 seconds)
                const maxAttempts = 15;  // 30 seconds total
                let attempts = 0;

                const pollForResults = async () => {
                    attempts++;

                    try {
                        // Fetch the updated article
                        const article = await api.getArticle(id);
                        state.parserResults = article.parser_results || {};

                        // Also update the article in the cached list
                        const cachedArticle = state.articles.find(a => a.id === id);
                        if (cachedArticle) {
                            // Update relevant fields from the refreshed article
                            Object.assign(cachedArticle, {
                                title: article.title,
                                author: article.author,
                                snippet: article.snippet,
                                text_length: article.text_length,
                                readTime: article.readTime
                            });
                        }

                        // Check if the current parser has new results
                        const parserResult = state.parserResults[mode];

                        // If we have a result (success or failure), stop polling
                        if (parserResult) {
                            // Update the content display
                            await app.setParser(mode);

                            if (els.redriveIcon) els.redriveIcon.classList.remove('fa-spin');

                            if (parserResult.success) {
                                console.log(`Parser ${mode} results updated successfully`);
                            } else {
                                console.warn(`Parser ${mode} failed:`, parserResult.error || 'Unknown error');
                                // Show error message to user
                                if (els.rContent) {
                                    const errorMsg = parserResult.error || 'Parser failed';
                                    els.rContent.innerHTML = `
                                        <div class="bg-red-900/20 border border-red-500/30 rounded-lg p-6 text-center">
                                            <i class="fa-solid fa-triangle-exclamation text-red-400 text-2xl mb-3"></i>
                                            <h3 class="text-red-400 font-mono text-sm mb-2">PARSER FAILED</h3>
                                            <p class="text-dim text-xs">${utils.escapeHtml(errorMsg)}</p>
                                        </div>
                                    `;
                                }
                            }
                            return true;
                        }

                        // Continue polling if we haven't exceeded max attempts
                        if (attempts < maxAttempts) {
                            setTimeout(() => pollForResults(), 2000);
                            return false;
                        } else {
                            // Timeout - stop spinning but don't show error (might still be processing)
                            if (els.redriveIcon) els.redriveIcon.classList.remove('fa-spin');
                            console.log(`Polling timeout - parser may still be processing`);
                            return false;
                        }
                    } catch (error) {
                        console.error('Error polling for results:', error);
                        if (attempts < maxAttempts) {
                            setTimeout(() => pollForResults(), 2000);
                        } else {
                            if (els.redriveIcon) els.redriveIcon.classList.remove('fa-spin');
                        }
                        return false;
                    }
                };

                // Start polling after a short delay
                setTimeout(() => pollForResults(), 2000);
            },

            setupAudio(article) {
                const hasAudio = article.audio && article.audio.available;

                if (hasAudio) {
                    // Show player, hide generate button
                    if (els.audioPlayerSection) els.audioPlayerSection.classList.remove('hidden');
                    if (els.audioGenerateSection) els.audioGenerateSection.classList.add('hidden');

                    // Set audio source
                    if (els.audioSource && els.audioPlayer) {
                        els.audioSource.src = `/audio/${article.id}.wav`;
                        els.audioPlayer.load();
                    }

                    // Set duration
                    if (els.audioDuration && article.audio.duration) {
                        const minutes = Math.floor(article.audio.duration / 60);
                        const seconds = Math.floor(article.audio.duration % 60);
                        els.audioDuration.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }

                    // Reset playback speed
                    if (els.audioPlayer) {
                        els.audioPlayer.playbackRate = 1.0;
                    }
                    if (els.audioSpeedBtn) {
                        els.audioSpeedBtn.textContent = '1.0x';
                    }
                } else {
                    // Show generate button, hide player
                    if (els.audioPlayerSection) els.audioPlayerSection.classList.add('hidden');
                    if (els.audioGenerateSection) els.audioGenerateSection.classList.remove('hidden');
                }
            },

            async generateAudio() {
                const id = state.currentArticleId;
                if (!id) return;

                const btn = els.generateAudioBtn;
                if (!btn) return;

                // Disable button and show loading state
                const originalHTML = btn.innerHTML;
                btn.disabled = true;
                btn.innerHTML = `
                    <i class="fa-solid fa-spinner fa-spin text-cyan-400"></i>
                    <span class="font-mono text-xs text-cyan-400">GENERATING AUDIO...</span>
                `;

                try {
                    const response = await fetch(`/articles/${id}/generate-audio`, {
                        method: 'POST'
                    });

                    const result = await response.json();

                    if (result.success) {
                        // Reload article to get updated audio metadata
                        const article = await api.getArticle(id);
                        app.setupAudio(article);

                        ui.showSuccess(`Audio generated: ${Math.floor(result.duration)}s`);
                    } else {
                        ui.showError(`Failed to generate audio: ${result.error}`);
                        btn.disabled = false;
                        btn.innerHTML = originalHTML;
                    }
                } catch (error) {
                    console.error('Error generating audio:', error);
                    ui.showError('Failed to generate audio');
                    btn.disabled = false;
                    btn.innerHTML = originalHTML;
                }
            },

            cycleAudioSpeed() {
                if (!els.audioPlayer || !els.audioSpeedBtn) return;

                const speeds = [1.0, 1.5, 2.0];
                const currentSpeed = els.audioPlayer.playbackRate;
                const currentIndex = speeds.indexOf(currentSpeed);
                const nextIndex = (currentIndex + 1) % speeds.length;
                const nextSpeed = speeds[nextIndex];

                els.audioPlayer.playbackRate = nextSpeed;
                els.audioSpeedBtn.textContent = `${nextSpeed}x`;
            },

            async deleteArticle(id) {
                if (!confirm("Delete article?")) return;

                try {
                    await api.deleteArticle(id);

                    if (typeof db !== 'undefined') {
                        await db.deleteArticle(id);
                    }

                    state.articles = state.articles.filter(a => a.id !== id);
                    app.renderLibrary();
                    app.renderGroupList();
                } catch (error) {
                    console.error('Delete failed:', error);
                    ui.showError("Failed to delete article");
                }
            },

            async deleteCurrent() {
                if (state.currentArticleId) {
                    await app.deleteArticle(state.currentArticleId);
                    app.goHome();
                }
            },

            // Audio Player
            setupAudio(article) {
                // Hide audio bar and reset state
                if (els.audioBar) {
                    els.audioBar.classList.add('hidden', 'translate-y-full');
                    els.audioBar.classList.remove('translate-y-0');
                }
                if (els.audio) {
                    els.audio.pause();
                    els.audio.src = '';
                }
                state.audioUrl = null;
                state.isGeneratingAudio = false;

                // Clear audio mode and reset reading map
                if (els.rContent && els.rContent.parentElement) {
                    els.rContent.parentElement.classList.remove('audio-mode');
                }
                if (state.readingMap) {
                    state.readingMap.forEach(item => item.el.classList.remove('active-reading-block'));
                }
                state.readingMap = [];

                // Check if audio is available
                if (article.audio && article.audio.available) {
                    // Audio already generated - set up player
                    const audioUrl = `/audio/${article.id}.wav`;
                    state.audioUrl = audioUrl;
                    if (els.audio) {
                        els.audio.src = audioUrl;
                    }
                    if (els.btnGenerateAudio) {
                        els.btnGenerateAudio.innerHTML = '<i class="fa-solid fa-headphones"></i><span>LISTEN</span>';
                    }
                } else {
                    // No audio yet - show generate button
                    if (els.btnGenerateAudio) {
                        els.btnGenerateAudio.innerHTML = '<i class="fa-solid fa-headphones"></i><span>LISTEN</span>';
                    }
                }

                // Setup text-click scrubbing
                if (els.rContent) {
                    els.rContent.onclick = (e) => app.scrubAudioByText(e);
                }
            },

            async generateAudio() {
                const id = state.currentArticleId;
                if (!id || state.isGeneratingAudio) return;

                // If audio already exists, just play it
                if (state.audioUrl && els.audio && els.audio.src) {
                    // Show audio bar and play
                    if (els.audioBar) {
                        els.audioBar.classList.remove('hidden', 'translate-y-full');
                        els.audioBar.classList.add('translate-y-0');
                    }
                    // Enable audio mode
                    if (els.rContent) {
                        els.rContent.parentElement.classList.add('audio-mode');
                    }
                    // Calculate reading map if not already done
                    if (state.readingMap.length === 0 && els.audio.duration) {
                        app.calculateReadingMap();
                    }
                    app.toggleAudioPlay();
                    return;
                }

                // Generate new audio
                state.isGeneratingAudio = true;
                if (els.btnGenerateAudio) {
                    els.btnGenerateAudio.innerHTML = '<i class="fa-solid fa-circle-notch fa-spin"></i><span>GENERATING...</span>';
                    els.btnGenerateAudio.classList.add('opacity-50', 'cursor-not-allowed');
                }

                try {
                    const response = await fetch(`/articles/${id}/generate-audio`, {
                        method: 'POST'
                    });

                    if (!response.ok) {
                        throw new Error('Audio generation failed');
                    }

                    const result = await response.json();

                    if (result.success) {
                        // Set up audio player
                        const audioUrl = `/audio/${id}.wav`;
                        state.audioUrl = audioUrl;
                        if (els.audio) {
                            els.audio.src = audioUrl;

                            // Wait for metadata to load before building map
                            els.audio.onloadedmetadata = () => {
                                app.calculateReadingMap();
                                app.toggleAudioPlay();
                            };
                        }

                        // Show audio bar
                        if (els.audioBar) {
                            els.audioBar.classList.remove('hidden', 'translate-y-full');
                            els.audioBar.classList.add('translate-y-0');
                        }

                        // Enable audio mode styles
                        if (els.rContent) {
                            els.rContent.parentElement.classList.add('audio-mode');
                        }

                        if (els.btnGenerateAudio) {
                            els.btnGenerateAudio.innerHTML = '<i class="fa-solid fa-headphones"></i><span>LISTEN</span>';
                        }
                    } else {
                        throw new Error(result.error || 'Audio generation failed');
                    }
                } catch (error) {
                    console.error('Audio generation error:', error);
                    ui.showError('Failed to generate audio: ' + error.message);
                    if (els.btnGenerateAudio) {
                        els.btnGenerateAudio.innerHTML = '<i class="fa-solid fa-headphones"></i><span>LISTEN</span>';
                    }
                } finally {
                    state.isGeneratingAudio = false;
                    if (els.btnGenerateAudio) {
                        els.btnGenerateAudio.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                }
            },

            async calculateReadingMap() {
                const duration = els.audio.duration;
                if (!duration || !isFinite(duration) || !els.rContent) return;

                // Get ALL significant text elements recursively (not just direct children)
                const selector = 'p, blockquote, h1, h2, h3, h4, h5, h6, ul, ol';
                const allElements = els.rContent.querySelectorAll(selector);

                // Filter to only elements with meaningful text content
                const children = Array.from(allElements).filter(el => {
                    return el.textContent.trim().length > 0;
                });

                if (children.length === 0) {
                    console.warn('No text elements found for reading map');
                    return;
                }

                // Calculate word-based heuristic estimates first
                let totalWeight = 0;
                const items = children.map(child => {
                    const text = child.textContent.trim();

                    // Count words (more accurate than characters for speech)
                    const wordCount = text.split(/\s+/).length;

                    // Count sentence-ending punctuation (adds pauses in TTS)
                    const sentenceEnds = (text.match(/[.!?]+/g) || []).length;

                    // Count commas/semicolons (shorter pauses)
                    const shortPauses = (text.match(/[,;:]/g) || []).length;

                    // Weight: 1 per word + 3 extra for sentence ends + 1 for short pauses
                    const weight = wordCount + (sentenceEnds * 3) + shortPauses;

                    totalWeight += weight;
                    return { child, weight, wordCount, text };
                });

                // Calculate estimated segment boundaries using word weights
                let currentTime = 0;
                const heuristicBoundaries = [];
                items.forEach((item, idx) => {
                    const segmentDuration = (item.weight / totalWeight) * duration;
                    heuristicBoundaries.push({
                        idx: idx,
                        start: currentTime,
                        end: currentTime + segmentDuration
                    });
                    currentTime += segmentDuration;
                });

                // Try to detect actual pauses in the audio
                let detectedPauses = [];
                try {
                    detectedPauses = await app.analyzeAudioForPauses();
                    console.log(`Detected ${detectedPauses.length} pauses in audio`);
                } catch (err) {
                    console.warn('Audio pause detection failed, using heuristic only:', err);
                }

                // Hybrid approach: Use heuristic boundaries, but snap to nearby detected pauses
                const snapTolerance = 0.75; // Look for pauses within Â±0.75s of heuristic estimate
                let snappedCount = 0;
                let previousEnd = 0;

                state.readingMap = items.map((item, idx) => {
                    const heuristic = heuristicBoundaries[idx];
                    let actualStart = previousEnd;
                    let actualEnd = heuristic.end;

                    // For the end boundary (start of next segment), try to snap to a detected pause
                    if (idx < items.length - 1 && detectedPauses.length > 0) {
                        // Find the nearest pause to our heuristic end time
                        const nearbyPause = detectedPauses.find(pauseTime => {
                            return Math.abs(pauseTime - heuristic.end) <= snapTolerance;
                        });

                        if (nearbyPause) {
                            actualEnd = nearbyPause;
                            snappedCount++;
                        }
                    }

                    // Last segment always ends at duration
                    if (idx === items.length - 1) {
                        actualEnd = duration;
                    }

                    // Update previousEnd for next iteration
                    previousEnd = actualEnd;

                    return {
                        el: item.child,
                        start: actualStart,
                        end: actualEnd
                    };
                });

                console.log(`Reading map created: ${state.readingMap.length} segments (${snappedCount} snapped to detected pauses, ${items.length - snappedCount} using heuristic)`);
            },

            async analyzeAudioForPauses() {
                if (!els.audio || !els.audio.src) {
                    throw new Error('No audio source available');
                }

                // Fetch the audio file
                const response = await fetch(els.audio.src);
                const arrayBuffer = await response.arrayBuffer();

                // Create audio context and decode
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                // Get audio data (use first channel if stereo)
                const channelData = audioBuffer.getChannelData(0);
                const sampleRate = audioBuffer.sampleRate;

                // Parameters for pause detection
                const windowSize = Math.floor(sampleRate * 0.05); // 50ms windows
                const silenceThreshold = 0.02; // Amplitude threshold for silence
                const minPauseDuration = 0.3; // Minimum 300ms pause to detect (we'll filter by proximity later)

                const pauses = [];
                let silenceStart = null;

                // Analyze audio in windows
                for (let i = 0; i < channelData.length; i += windowSize) {
                    // Calculate RMS (root mean square) for this window
                    let sum = 0;
                    const end = Math.min(i + windowSize, channelData.length);
                    for (let j = i; j < end; j++) {
                        sum += channelData[j] * channelData[j];
                    }
                    const rms = Math.sqrt(sum / (end - i));

                    const currentTime = i / sampleRate;

                    if (rms < silenceThreshold) {
                        // We're in silence
                        if (silenceStart === null) {
                            silenceStart = currentTime;
                        }
                    } else {
                        // We're in audio
                        if (silenceStart !== null) {
                            const pauseDuration = currentTime - silenceStart;
                            if (pauseDuration >= minPauseDuration) {
                                // Found a significant pause - use the midpoint
                                pauses.push(silenceStart + pauseDuration / 2);
                            }
                            silenceStart = null;
                        }
                    }
                }

                // Close audio context to free resources
                audioContext.close();

                console.log(`Detected ${pauses.length} pauses in audio:`, pauses.map(p => p.toFixed(2) + 's'));
                return pauses;
            },

            toggleAudioPlay() {
                if (!els.audio) return;

                if (els.audio.paused) {
                    els.audio.play();
                    if (els.audioPlayIcon) {
                        els.audioPlayIcon.classList.remove('fa-play');
                        els.audioPlayIcon.classList.add('fa-pause');
                    }
                    if (els.audioStatusText) {
                        els.audioStatusText.textContent = 'PLAYING AUDIO';
                    }
                } else {
                    els.audio.pause();
                    if (els.audioPlayIcon) {
                        els.audioPlayIcon.classList.remove('fa-pause');
                        els.audioPlayIcon.classList.add('fa-play');
                    }
                    if (els.audioStatusText) {
                        els.audioStatusText.textContent = 'AUDIO PAUSED';
                    }
                }
            },

            changePlaybackRate() {
                if (!els.audio) return;

                const rates = [1.0, 1.5, 2.0];
                const currentRate = els.audio.playbackRate;
                const currentIndex = rates.indexOf(currentRate);
                const nextIndex = (currentIndex + 1) % rates.length;
                const nextRate = rates[nextIndex];

                els.audio.playbackRate = nextRate;
                if (els.audioSpeedDisplay) {
                    els.audioSpeedDisplay.textContent = nextRate.toFixed(1) + 'x';
                }
            },

            seekAudio(e) {
                if (!els.audio || !els.audio.duration) return;

                const bar = e.currentTarget;
                const rect = bar.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const width = rect.width;
                const percent = Math.min(Math.max(0, clickX / width), 1);

                els.audio.currentTime = els.audio.duration * percent;

                // Resume playback if paused
                if (els.audio.paused) {
                    app.toggleAudioPlay();
                }
            },

            updateAudioProgress() {
                if (!els.audio || !els.audio.duration || !els.audioProgress) return;

                // Update progress bar
                const percent = (els.audio.currentTime / els.audio.duration) * 100;
                els.audioProgress.style.width = `${percent}%`;

                // Update karaoke-style highlighting
                const now = els.audio.currentTime;

                if (state.readingMap && state.readingMap.length > 0) {
                    state.readingMap.forEach(item => {
                        if (now >= item.start && now < item.end) {
                            if (!item.el.classList.contains('active-reading-block')) {
                                // Clear previous highlights
                                document.querySelectorAll('.active-reading-block').forEach(el =>
                                    el.classList.remove('active-reading-block')
                                );
                                // Highlight current block
                                item.el.classList.add('active-reading-block');

                                // Auto-scroll to keep active block in view
                                item.el.scrollIntoView({
                                    behavior: 'smooth',
                                    block: 'center'
                                });
                            }
                        }
                    });
                }
            },

            onAudioEnded() {
                if (els.audioPlayIcon) {
                    els.audioPlayIcon.classList.remove('fa-pause');
                    els.audioPlayIcon.classList.add('fa-play');
                }
                if (els.audioStatusText) {
                    els.audioStatusText.textContent = 'AUDIO FINISHED';
                }
                if (els.audioProgress) {
                    els.audioProgress.style.width = '100%';
                }

                // Clear karaoke highlighting
                if (state.readingMap) {
                    state.readingMap.forEach(item => item.el.classList.remove('active-reading-block'));
                }
            },

            scrubAudioByText(e) {
                // Only scrub if audio bar is visible and reading map exists
                if (!state.audioUrl || !els.audioBar || els.audioBar.classList.contains('hidden')) {
                    return;
                }
                if (!els.audio || !els.audio.duration || !isFinite(els.audio.duration)) {
                    return;
                }
                if (!state.readingMap || state.readingMap.length === 0) {
                    return;
                }

                // Find which paragraph/block was clicked
                const target = e.target.closest('p, h1, h2, h3, h4, h5, h6, blockquote, ul, ol');
                if (!target) return;

                // Find the segment for this element in the reading map
                const segment = state.readingMap.find(item => item.el === target);

                if (segment) {
                    // Seek to the start of this paragraph
                    els.audio.currentTime = segment.start;

                    // Resume playback if paused
                    if (els.audio.paused) {
                        app.toggleAudioPlay();
                    }

                    // Visual feedback
                    if (els.audioStatusText) {
                        els.audioStatusText.textContent = 'SEEKING TO PARAGRAPH...';
                        setTimeout(() => {
                            if (els.audioStatusText) {
                                els.audioStatusText.textContent = 'PLAYING AUDIO';
                            }
                        }, 500);
                    }
                }
            },

            // Bookmarklet
            openBookmarkletModal() {
                els.bookmarkletModal?.classList.remove('hidden');
            },

            closeBookmarkletModal() {
                els.bookmarkletModal?.classList.add('hidden');
            },

            generateBookmarklet() {
                if (els.bookmarkletLink) {
                    els.bookmarkletLink.href = 'javascript:(function(){window.open("' + CONFIG.API_BASE + '/save?url="+encodeURIComponent(window.location.href))})();';
                }
            }
        };

        // =============================================================================
        // Initialize
        // =============================================================================

        app.init();
    </script>
</body>
</html>
